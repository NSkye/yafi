# yafi
Yet another Flux implementation.  
Простая библиотека, представляющая собой имплементацию Flux-архитектуры.

## Использование
### Создание хранилища
Хранилище создается путем вызова его конструктора:
```javascript
const { Store } = require(yafi);

let initialS = { /* ... */ };
function someReducer(state = initialS, action) { /* ... */ }

let myStore = new Store(someReducer);
```
Конструктор хранилища принимает на вход один или несколько редьюсеров:
```typescript
// Вариант 1
interface Store {
  new (reducer: ClassicReducer | AutoReducer)
  // ...
}
// Вариант 2
interface Store {
  new (...reducer: ClassicReducer[])
  // ...
}
```
Как видно из описания выше, существует два вида редьюсеров: ClassicReducer и AutoReducer. Первый вариант можно использовать всегда и везде. Второй можно передавать только если он является единственным редьюсером. Для того чтобы использовать несколько авторедьюсеров их нужно нормализовать (привести к виду классических) или скомбинировать с помощью метода combineReducers. Обо всём этом чуть ниже.
### Виды Редьюсеров
#### ClassicReducer
Классический редьюсер имеет следующую сигнатуру:
```typescript
type ClassicReducer = (state: YafiState | undefined, action: Action | undefined) => YafiState
```
Пример использования:
```javascript
const initialState = { count: 0 };
function myClassicReducer (state = initialState, action) {
  const newState = { ...state };
  if (action.type === 'increment') {
    newState.count = state.count + 1;
  }
  return newState;
}
```
Примерно в таком же виде редьюсеры пишутся для Redux. Ему передается два аргумента: состояние и действие. Внутри себя редьюсер должен выбрать соответствующую типу действия операцию и применить её к состоянию. Стоит заметить, что так как в редьюсер передается оригинальное состояние без каких-либо оберток, нужно следить за иммутабельностью и всегда копировать изменяемый объект, вместо того, чтоб получать доступ к нему напрямую. Редьюсер возвращает новое состояние, которое впоследствии будет применено в store.
#### AutoReducer
У авторедьюсера сигнатура несколько отличается:
```typescript
interface AutoReducer {
  state: YafiState,
  actions?: {
    [action: string]: (stateShallowCopy: YafiState, payload?: unknown) => void
  }
}
```
Пример использования, идентичный предыдущему:
```javascript
const myAutoReducer = {
  state: { count: 0 },
  actions: {
    increment(stateCopy) {
      stateCopy.count+=1;
    }
  }
}
```
Как можно видеть, основное отличие состоит в том, что авторедьюсер это объект, который содержит 1-2 атрибута: 1) начальное состояние, 2) действия.  
Поскольку действия в данном случае уже представлены как именованные атрибуты, нет нужды в реализации логики выбора нужного действия. Также, стоит заметить, что в хэндлер экшена передается сразу поверхностная копия состояния, которую надо просто изменить. Это всё существенно уменьшает количество повторяющегося кода. Но стоит помнить, что копия состояния всё ещё только поверхностная. Если требуется изменить вложенный объект, то его нужно так же как и в случае с классическим редьюсером скопировать с помощью ...spread-оператора, изменить и только потом присвоить на нужное место.  
Ещё одно немаловажное отличие, что хэндлер сразу получает payload, без самого действия, поскольку нужное действие уже было выбрано.  
### Нормализация редьюсеров
Позволяет привести любой редьюсер к виду ClassicReducer. В большинстве случаев такое явное приведение не требуется, так как Store выполнит в своём конструкторе все необходимые операции. Но если вдруг возникла надобность, то это делается следующим образом:
```javascript
const { normalizeReducer } = require('yafi');
// ...
const normalized1 = normalizeReducer(myClassicReducer);
normalized1 === myClassicReducer // -> true , если редьюсер и так имеет классический функциональный вид, то он будет просто возвращен
const normalized2 = normalizeReducer(myAutoReducer);
normalized2 === myClassicReducer // -> false , но функционал и API теперь абсолютно те же самые
```
### Объединение редьюсеров
Данная операция позволяет объединить несколько редьюсеров, если по какой-то причине (например, ради семантики) они должны находиться отдельно друг от друга, но при этом относиться к одному хранилищу. Использование с редьюсерами, объявленными в прошлых примерах выглядит следующим образом:
```javascript
const { combineReducers } = require('yafi');

const combinedReducer = combineReducers({
  r1: myClassicReducer,
  r2: myAutoReducer
});
```
В результате, изначальное состояние стора, если передать ему этот редьюсер будет таким:
```javascript
{
  r1: { count: 0 },
  r2: { count: 0 }
}
```
Оба скомбинированных редьюсера будут видеть все посылаемые хранилищу действия и реагировать на них, при этом их собственные состояния будут оставаться изолированными друг от друга. Каждый редьюсер будет иметь возможность оперировать только со своим состоянием и не будет иметь представления об общем состоянии стора, т.е. r2 ничего не знает об r1 и наоборот. Весь API при этом остается прежним.  
Второй вариант объединения предполагает передачу в качестве аргумента массива редьюсеров:
```javascript
const { combineReducers } = require('yafi');

function r1 (state = { count: 0 }, action) { /* ... */ };
function r2 (state = { count: 0 }, action) { /* ... */ };

const combinedReducer = combineReducers([ r1, r2 ]);
```
Но такой способ вызова работает только с классическими редьюсерами и только когда они представлены в виде именованных функций. Поскольку их имена будут использованы, чтобы создать неймспейс для каждого редьюсера внутри состояния. Если же используются авторедьюсеры или классические редьюсеры заданы анонимными функциями, стоит использовать предыдущий вариант объединения.
#### Неявное объединение
Работает по тем же правилам, что второй вариант вызова combineReducers, только редьюсеры передаются сразу в конструктор хранилища и без массива:
```javascript
let myStore = new Store(someClassicReducer1, someClassicReducer2, someClassicReducer3);
```
### Действия и подписки
Любое действие должно иметь следующую сигнатуру:
```typescript
interface Action { 
  type: string, 
  payload?: any 
}
```
Где type - тип действия, а payload - любая информация, которую нужно передать в редьюсер.
Вызов действия осуществляется следующим образом:
```javascript
/* ... */
store.dispatch({ type: 'someAction', payload: 'someData' });
// или
store.do({ type: 'someAction', payload: 'someData' });
/* ... */
```
После этого действие попадет в редьюсер и он сможет его обработать.  
Подписаться на обновление состояния хранилища можно с помощью метода subscribe.
Например.
```javascript
/* ... */
const logState = state => console.log(state);
store.subscribe(logState);
/* ... */
```
Коллбэк, переданный в subscribe будет вызываться каждый раз после отработки редьюсера.
Чтобы отписаться от обновления состояния можно просто воспользоваться методом unsubscribe:
```javascript
/* ... */
store.unsubscribe(logState);
/* ... */
```
